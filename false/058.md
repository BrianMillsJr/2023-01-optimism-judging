HE1M

unlabeled

# Fake

## Summary

## Vulnerability Detail

For simplicity assume that:
 - length of the array `l2Outputs` is 100, so there are already the l2Outputs indices 0 to 99.
 https://github.com/sherlock-audit/2023-01-optimism/blob/main/optimism/packages/contracts-bedrock/contracts/L1/L2OutputOracle.sol#L50
 - `startingBlockNumber` is 1000.
 - https://github.com/sherlock-audit/2023-01-optimism/blob/main/optimism/packages/contracts-bedrock/contracts/L1/L2OutputOracle.sol#L40
 - `SUBMISSION_INTERVAL` is 120. It means that `l2Outputs[0].l2BlockNumber` is equal to `1120` (1000 + 120), and for the last index we have `l2Outputs[99].l2BlockNumber` equal to `13000` (1000 + 100*120)
 - https://github.com/sherlock-audit/2023-01-optimism/blob/main/optimism/packages/contracts-bedrock/contracts/L1/L2OutputOracle.sol#L20

Suppose Alice (an innocent user with a large amount of fund) sends a withdrawal message to `L2ToL1MessagePasser` on L2 to receive her fund on L1.

Bob (the malicious proposer) puts Alice's L2 transaction data into L2 blocks `13100` and `13200` (please note that `latestBlockNumber` is now 13000 and there are now 100 `l2Outputs`. So blocks `13001` to `13120` will be inserted into l2Output with index 100, and blocks `13121` to `13240` will be inserted into l2Output index 101). 

Bob generates correct `_outputRoot` and calls the function `proposeL2Output` to propose the l2Output with block number 13120 with following parameters:
 - `_outputRoot` = correct data
 - `_l2BlockNumber` = 13120
 - `_l1BlockHash` = not important for this scenario
 -  `_l1BlockNumber` = not important for this scenario
https://github.com/sherlock-audit/2023-01-optimism/blob/main/optimism/packages/contracts-bedrock/contracts/L1/L2OutputOracle.sol#L160

So, `l2Outputs[100].l2BlockNumber` is 13120 with valid `outputRoot`.

Then Bob generates fake `_outputRoot` and calls the `proposeL2Output` to propose the l2Output with block number 13240 with following parameters:
 - `_outputRoot` = fake data
 - `_l2BlockNumber` = 13240 
 - `_l1BlockHash` = not important for this scenario
 -  `_l1BlockNumber` = not important for this scenario
 
So, `l2Outputs[101].l2BlockNumber` is 13240 with invalid `outputRoot`.

Then Bob calls the function `proveWithdrawalTransaction` to prove Alice's withdrawal transaction with the following parameters:
 - `_tx` = Alice's withdrawal transaction
 - `_l2OutputIndex` = **101**
 - `_outputRootProof` = fake data 
 - `_withdrawalProof` = fake data
https://github.com/sherlock-audit/2023-01-optimism/blob/main/optimism/packages/contracts-bedrock/contracts/L1/OptimismPortal.sol#L160

Please note that since the proposed l2Output with index 101 has fake `outputRoot` (it is generated by Bob), so the following check can be passed easily:
https://github.com/sherlock-audit/2023-01-optimism/blob/main/optimism/packages/contracts-bedrock/contracts/L1/OptimismPortal.sol#L180

Since this withdrawal transaction is the first time to be proved, its timestamp is equal to zero:
https://github.com/sherlock-audit/2023-01-optimism/blob/main/optimism/packages/contracts-bedrock/contracts/L1/OptimismPortal.sol#L195

Since `messagePasserStorageRoot` is part of the struct `_outputRootProof ` (this is also generated by Bob), and also the `_withdrawalProof` is provided by Bob, the following check will be easily passed:
https://github.com/sherlock-audit/2023-01-optimism/blob/main/optimism/packages/contracts-bedrock/contracts/L1/OptimismPortal.sol#L215

In other words, Bob create the fake data as follows:
any fake data as `_withdrawalProof` with a `storageKey` (this is generated from the `withdrawalHash`) as leave, will result in a arbitrary `messagePasserStorageRoot`.


Finally the mapping `provenWithdrawals[Alice's withdrawalHash]` will be updated as follows:
 - `outputRoot` = fake value proposed by Bob
 - `timestamp` = current timestamp
 - `l2OutputIndex` = **101**

Then during the challenge window, the verifier notices something is wrong with l2Output index 101. The verifiers sees that there is totally invalid data (`OutputRoot`). So, the `Challenger` deletes the l2Output index 101 by calling the function `deleteL2Outputs`:
https://github.com/sherlock-audit/2023-01-optimism/blob/main/optimism/packages/contracts-bedrock/contracts/L1/L2OutputOracle.sol#L128

Please note that Alice's withdrawal transaction was included in block 13100 as well as 13200. Block 13100 was part of l2Output 100 which has valid data (so it is not going to be challenged). But block 13200 was part of l2Output 101 which is challenged and deleted. 

Later, new l2Outputs will be proposed by honest proposer, and the proposer is not going to include Alice's withdrawal transaction in l2Outputs 101, 102, or anything after. Because, her transaction is already in l2Output 100.

Then, Alice decides to finalize her withdrawal on L1, and she calls the function `finalizeWithdrawalTransaction`:
https://github.com/sherlock-audit/2023-01-optimism/blob/main/optimism/packages/contracts-bedrock/contracts/L1/OptimismPortal.sol#L243

But it will be reverted, because the l2Output 101 (that includes Alice's transaction) now has different `outputRoot`:
https://github.com/sherlock-audit/2023-01-optimism/blob/main/optimism/packages/contracts-bedrock/contracts/L1/OptimismPortal.sol#L291

So, Alice decides to prove her transaction first by calling the function `proveWithdrawalTransaction`. But it reverts also:
- First: her transaction has already a non-zero timestamp (it was one proved by Bob with fake data).
- Second: her transaction is included in l2Output 100 while the mapping `provenWithdrawals[Alice's withdrawalHash] = 101`.
https://github.com/sherlock-audit/2023-01-optimism/blob/main/optimism/packages/contracts-bedrock/contracts/L1/OptimismPortal.sol#L196

## Impact

## Code Snippet

## Tool used

Manual Review

## Recommendation
